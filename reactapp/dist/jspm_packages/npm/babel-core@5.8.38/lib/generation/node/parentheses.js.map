{"version":3,"sources":["../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/generation/node/parentheses.js"],"names":["exports","__esModule","NullableTypeAnnotation","UpdateExpression","ObjectExpression","Binary","BinaryExpression","SequenceExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ConditionalExpression","AssignmentExpression","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_interopRequireDefault","_lodashCollectionEach","require","_lodashCollectionEach2","_types","t","PRECEDENCE","tier","i","op","node","parent","isArrayTypeAnnotation","FunctionTypeAnnotation","isMemberExpression","object","isExpressionStatement","isCallExpression","isNewExpression","callee","isUnaryLike","isBinary","parentOp","operator","parentPos","nodeOp","nodePos","right","isLogicalExpression","isVariableDeclarator","isFor","isForStatement","expression","isReturnStatement","isConditionalExpression","isYieldExpression","test","isObjectPattern","left","apply","undefined","arguments"],"mappings":"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","file":"parentheses.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.AssignmentExpression = AssignmentExpression;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Create a mapping of operators to precendence.\n *\n * @example\n * { \"==\": 6, \"+\": 9 }\n */\nvar PRECEDENCE = {};\n\n_lodashCollectionEach2[\"default\"]([[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]], function (tier, i) {\n  _lodashCollectionEach2[\"default\"](tier, function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\n/**\n * Test if NullableTypeAnnotation needs parentheses.\n */\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\n/**\n * Alias NullableTypeAnnotation test as FunctionTypeAnnotation.\n */\n\nexports.FunctionTypeAnnotation = NullableTypeAnnotation;\n\n/**\n * Test if UpdateExpression needs parentheses.\n */\n\nfunction UpdateExpression(node, parent) {\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    // (foo++).test()\n    return true;\n  }\n}\n\n/**\n * Test if ObjectExpression needs parentheses.\n */\n\nfunction ObjectExpression(node, parent) {\n  if (t.isExpressionStatement(parent)) {\n    // ({ foo: \"bar\" });\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    // ({ foo: \"bar\" }).foo\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Test if Binary needs parentheses.\n */\n\nfunction Binary(node, parent) {\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {\n    return true;\n  }\n\n  if (t.isUnaryLike(parent)) {\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    var parentOp = parent.operator;\n    var parentPos = PRECEDENCE[parentOp];\n\n    var nodeOp = node.operator;\n    var nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos > nodePos) {\n      return true;\n    }\n\n    // Logical expressions with the same precedence don't need parens.\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent)) {\n      return true;\n    }\n  }\n}\n\n/**\n * Test if BinaryExpression needs parentheses.\n */\n\nfunction BinaryExpression(node, parent) {\n  if (node.operator === \"in\") {\n    // var i = (1 in []);\n    if (t.isVariableDeclarator(parent)) {\n      return true;\n    }\n\n    // for ((1 in []);;);\n    if (t.isFor(parent)) {\n      return true;\n    }\n  }\n}\n\n/**\n * Test if SequenceExpression needs parentheses.\n */\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent)) {\n    // Although parentheses wouldn't hurt around sequence\n    // expressions in the head of for loops, traditional style\n    // dictates that e.g. i++, j++ should not be wrapped with\n    // parentheses.\n    return false;\n  }\n\n  if (t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  if (t.isReturnStatement(parent)) {\n    return false;\n  }\n\n  // Otherwise err on the side of overparenthesization, adding\n  // explicit exceptions above if this proves overzealous.\n  return true;\n}\n\n/**\n * Test if YieldExpression needs parentheses.\n */\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) || t.isYieldExpression(parent);\n}\n\n/**\n * Test if ClassExpression needs parentheses.\n */\n\nfunction ClassExpression(node, parent) {\n  return t.isExpressionStatement(parent);\n}\n\n/**\n * Test if UnaryLike needs parentheses.\n */\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent) && parent.object === node;\n}\n\n/**\n * Test if FunctionExpression needs parentheses.\n */\n\nfunction FunctionExpression(node, parent) {\n  // function () {};\n  if (t.isExpressionStatement(parent)) {\n    return true;\n  }\n\n  // (function test() {}).name;\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  // (function () {})();\n  if (t.isCallExpression(parent) && parent.callee === node) {\n    return true;\n  }\n}\n\n/**\n * Test if ConditionalExpression needs parentheses.\n */\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    return true;\n  }\n\n  if (t.isCallExpression(parent) || t.isNewExpression(parent)) {\n    if (parent.callee === node) {\n      return true;\n    }\n  }\n\n  if (t.isConditionalExpression(parent) && parent.test === node) {\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Test if AssignmentExpression needs parentheses.\n */\n\nfunction AssignmentExpression(node) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression.apply(undefined, arguments);\n  }\n}"]}