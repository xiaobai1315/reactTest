{"version":3,"sources":["../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/generation/whitespace.js"],"names":["exports","__esModule","_classCallCheck","instance","Constructor","TypeError","getLookupIndex","i","base","max","Whitespace","tokens","used","_lastFoundIndex","prototype","getNewlinesBefore","node","startToken","endToken","j","length","token","start","getNewlinesBetween","getNewlinesAfter","end","type","label","lines","loc","line","module"],"mappings":"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","file":"whitespace.js","sourcesContent":["/* */ \n\"format cjs\";\n/**\n * Returns `i`th number from `base`, continuing from 0 when `max` is reached.\n * Useful for shifting `for` loop by a fixed number but going over all items.\n *\n * @param {Number} i Current index in the loop\n * @param {Number} base Start index for which to return 0\n * @param {Number} max Array length\n * @returns {Number} shiftedIndex\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getLookupIndex(i, base, max) {\n  i += base;\n\n  if (i >= max) {\n    i -= max;\n  }\n\n  return i;\n}\n\n/**\n * Get whitespace around tokens.\n */\n\nvar Whitespace = (function () {\n  function Whitespace(tokens) {\n    _classCallCheck(this, Whitespace);\n\n    this.tokens = tokens;\n    this.used = {};\n\n    // Profiling this code shows that while generator passes over it, indexes\n    // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.\n\n    // We use this implementation detail for an optimization: instead of always\n    // starting to look from `this.tokens[0]`, we will start `for` loops from the\n    // previous successful match. We will enumerate all tokensâ€”but the common\n    // case will be much faster.\n\n    this._lastFoundIndex = 0;\n  }\n\n  /**\n   * Count all the newlines before a node.\n   */\n\n  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node starts with\n      if (node.start === token.start) {\n        startToken = tokens[i - 1];\n        endToken = token;\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    return this.getNewlinesBetween(startToken, endToken);\n  };\n\n  /**\n   * Count all the newlines after a node.\n   */\n\n  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node ends with\n      if (node.end === token.end) {\n        startToken = token;\n        endToken = tokens[i + 1];\n        if (endToken.type.label === \",\") endToken = tokens[i + 2];\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    if (endToken && endToken.type.label === \"eof\") {\n      return 1;\n    } else {\n      var lines = this.getNewlinesBetween(startToken, endToken);\n      if (node.type === \"CommentLine\" && !lines) {\n        // line comment\n        return 1;\n      } else {\n        return lines;\n      }\n    }\n  };\n\n  /**\n   * Count all the newlines between two tokens.\n   */\n\n  Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {\n    if (!endToken || !endToken.loc) return 0;\n\n    var start = startToken ? startToken.loc.end.line : 1;\n    var end = endToken.loc.start.line;\n    var lines = 0;\n\n    for (var line = start; line < end; line++) {\n      if (typeof this.used[line] === \"undefined\") {\n        this.used[line] = true;\n        lines++;\n      }\n    }\n\n    return lines;\n  };\n\n  return Whitespace;\n})();\n\nexports[\"default\"] = Whitespace;\nmodule.exports = exports[\"default\"];"]}