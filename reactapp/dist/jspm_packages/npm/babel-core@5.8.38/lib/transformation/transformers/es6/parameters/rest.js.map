{"version":3,"sources":["../../../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/transformation/transformers/es6/parameters/rest.js"],"names":["exports","__esModule","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_util","require","util","_types","t","memberExpressionOptimisationVisitor","Scope","node","parent","scope","state","bindingIdentifierEquals","name","outerBinding","skip","Flow","Function","oldNoOptimise","noOptimise","traverse","ReferencedIdentifier","deopted","parentPath","isMemberExpression","computed","object","prop","get","isBaseType","candidates","push","isSpreadElement","offset","isCallExpression","arguments","length","references","BindingIdentifier","optimiseMemberExpression","newExpr","property","isLiteral","value","raw","String","binaryExpression","literal","hasRest","isRestElement","params","visitor","restParam","pop","rest","argument","argsId","identifier","_shadowedFunctionLiteral","isPattern","pattern","generateUidIdentifier","declar","variableDeclaration","elements","map","elem","index","accessExpr","memberExpression","variableDeclarator","body","unshift","argumentsNode","getBindingIdentifier","_arr","_i","candidate","replaceWith","concat","shadow","start","len","arrKey","arrLen","conditionalExpression","loop","template","ARRAY_TYPE","typeAnnotation","ARGUMENTS","ARRAY_KEY","ARRAY_LEN","START","ARRAY","KEY","LEN","_blockHoist","target","getEarliestCommonAncestorFrom","getStatementParent","highestLoop","findParent","path","isLoop","isFunction","insertBefore"],"mappings":"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","file":"rest.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _util = require(\"../../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar memberExpressionOptimisationVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope: function Scope(node, parent, scope, state) {\n    // check if this scope has a local binding that will shadow the rest parameter\n    if (!scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      this.skip();\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Flow: function Flow() {\n    // don't touch reference in type annotations\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, state) {\n    // skip over functions as whatever `arguments` we reference inside will refer\n    // to the wrong function\n    var oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    this.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    // we can't guarantee the purity of arguments\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    // is this a referenced identifier and is it referencing the rest parameter?\n    if (node.name !== state.name) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      if (this.parentPath.isMemberExpression({ computed: true, object: node })) {\n        // if we know that this member expression is referencing a number then we can safely\n        // optimise it\n        var prop = this.parentPath.get(\"property\");\n        if (prop.isBaseType(\"number\")) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      // optimise single spread args in calls\n      if (this.parentPath.isSpreadElement() && state.offset === 0) {\n        var call = this.parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      state.references.push(this);\n    }\n  },\n\n  /**\n   * Deopt on use of a binding identifier with the same name as our rest param.\n   *\n   * See https://github.com/babel/babel/issues/2091\n   */\n\n  BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {\n    if (node.name === state.name) {\n      state.deopted = true;\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction optimiseMemberExpression(parent, offset) {\n  if (offset === 0) return;\n\n  var newExpr;\n  var prop = parent.property;\n\n  if (t.isLiteral(prop)) {\n    prop.value += offset;\n    prop.raw = String(prop.value);\n  } else {\n    // // UnaryExpression, BinaryExpression\n    newExpr = t.binaryExpression(\"+\", prop, t.literal(offset));\n    parent.property = newExpr;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction hasRest(node) {\n  return t.isRestElement(node.params[node.params.length - 1]);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope) {\n    if (!hasRest(node)) return;\n\n    var restParam = node.params.pop();\n    var rest = restParam.argument;\n\n    var argsId = t.identifier(\"arguments\");\n\n    // otherwise `arguments` will be remapped in arrow functions\n    argsId._shadowedFunctionLiteral = this;\n\n    // support patterns\n    if (t.isPattern(rest)) {\n      var pattern = rest;\n      rest = scope.generateUidIdentifier(\"ref\");\n\n      var declar = t.variableDeclaration(\"let\", pattern.elements.map(function (elem, index) {\n        var accessExpr = t.memberExpression(rest, t.literal(index), true);\n        return t.variableDeclarator(elem, accessExpr);\n      }));\n      node.body.body.unshift(declar);\n    }\n\n    // check and optimise for extremely common cases\n    var state = {\n      references: [],\n      offset: node.params.length,\n\n      argumentsNode: argsId,\n      outerBinding: scope.getBindingIdentifier(rest.name),\n\n      // candidate member expressions we could optimise if there are no other references\n      candidates: [],\n\n      // local rest binding name\n      name: rest.name,\n\n      // whether any references to the rest parameter were made in a function\n      deopted: false\n    };\n\n    this.traverse(memberExpressionOptimisationVisitor, state);\n\n    if (!state.deopted && !state.references.length) {\n      // we only have shorthands and there are no other references\n      if (state.candidates.length) {\n        var _arr = state.candidates;\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var candidate = _arr[_i];\n          candidate.replaceWith(argsId);\n          if (candidate.parentPath.isMemberExpression()) {\n            optimiseMemberExpression(candidate.parent, state.offset);\n          }\n        }\n      }\n      return;\n    } else {\n      state.references = state.references.concat(state.candidates);\n    }\n\n    // deopt shadowed functions as transforms like regenerator may try touch the allocation loop\n    state.deopted = state.deopted || !!node.shadow;\n\n    //\n\n    var start = t.literal(node.params.length);\n    var key = scope.generateUidIdentifier(\"key\");\n    var len = scope.generateUidIdentifier(\"len\");\n\n    var arrKey = key;\n    var arrLen = len;\n    if (node.params.length) {\n      // this method has additional params, so we need to subtract\n      // the index of the current argument position from the\n      // position in the array that we want to populate\n      arrKey = t.binaryExpression(\"-\", key, start);\n\n      // we need to work out the size of the array that we're\n      // going to store all the rest parameters\n      //\n      // we need to add a check to avoid constructing the array\n      // with <0 if there are less arguments than params as it'll\n      // cause an error\n      arrLen = t.conditionalExpression(t.binaryExpression(\">\", len, start), t.binaryExpression(\"-\", len, start), t.literal(0));\n    }\n\n    var loop = util.template(\"rest\", {\n      ARRAY_TYPE: restParam.typeAnnotation,\n      ARGUMENTS: argsId,\n      ARRAY_KEY: arrKey,\n      ARRAY_LEN: arrLen,\n      START: start,\n      ARRAY: rest,\n      KEY: key,\n      LEN: len\n    });\n\n    if (state.deopted) {\n      loop._blockHoist = node.params.length + 1;\n      node.body.body.unshift(loop);\n    } else {\n      // perform allocation at the lowest common denominator of all references\n      loop._blockHoist = 1;\n\n      var target = this.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n\n      // don't perform the allocation inside a loop\n      var highestLoop;\n      target.findParent(function (path) {\n        if (path.isLoop()) {\n          highestLoop = path;\n        } else if (path.isFunction()) {\n          // stop crawling up for functions\n          return true;\n        }\n      });\n      if (highestLoop) target = highestLoop;\n\n      target.insertBefore(loop);\n    }\n  }\n};\nexports.visitor = visitor;"]}