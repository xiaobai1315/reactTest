{"version":3,"sources":["../../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/transformation/transformers/other/regenerator.js"],"names":["exports","__esModule","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_interopRequireDefault","_regenerator","require","_regenerator2","_types","t","NodePath","types","metadata","group","visitor","Function","exit","node","async","generator","transform","convertNodePath","path","programNode","keysAlongPath","pp","parentPath","parentNode","push","container","found","keys","some","listKey","Error","isProgram","nodePath","length","get","pop"],"mappings":"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","file":"regenerator.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _regenerator = require(\"regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n// It's important to use the exact same NodePath constructor that\n// Regenerator uses, rather than require(\"ast-types\").NodePath, because\n// the version of ast-types that Babel knows about might be different from\n// the version that Regenerator depends on. See for example #1958.\nvar NodePath = _regenerator2[\"default\"].types.NodePath;\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: {\n    exit: function exit(node) {\n      if (node.async || node.generator) {\n        // Although this code transforms only the subtree rooted at the given\n        // Function node, that node might contain other generator functions\n        // that will also be transformed. It might help performance to ignore\n        // nested functions, and rely on the traversal to visit them later,\n        // but that's a small optimization. Starting here instead of at the\n        // root of the AST is the key optimization, since huge async/generator\n        // functions are relatively rare.\n        _regenerator2[\"default\"].transform(convertNodePath(this));\n      }\n    }\n  }\n};\n\nexports.visitor = visitor;\n// Given a Babel NodePath, return an ast-types NodePath that includes full\n// ancestry information (up to and including the Program node). This is\n// complicated by having to include intermediate objects like blockStatement.body\n// arrays, in addition to Node objects.\nfunction convertNodePath(path) {\n  var programNode;\n  var keysAlongPath = [];\n\n  while (path) {\n    var pp = path.parentPath;\n    var parentNode = pp && pp.node;\n    if (parentNode) {\n      keysAlongPath.push(path.key);\n\n      if (parentNode !== path.container) {\n        var found = Object.keys(parentNode).some(function (listKey) {\n          if (parentNode[listKey] === path.container) {\n            keysAlongPath.push(listKey);\n            return true;\n          }\n        });\n\n        if (!found) {\n          throw new Error(\"Failed to find container object in parent node\");\n        }\n      }\n\n      if (t.isProgram(parentNode)) {\n        programNode = parentNode;\n        break;\n      }\n    }\n\n    path = pp;\n  }\n\n  if (!programNode) {\n    throw new Error(\"Failed to find root Program node\");\n  }\n\n  var nodePath = new NodePath(programNode);\n\n  while (keysAlongPath.length > 0) {\n    nodePath = nodePath.get(keysAlongPath.pop());\n  }\n\n  return nodePath;\n}"]}