{"version":3,"sources":["../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/transformation/helpers/explode-assignable-expression.js"],"names":["exports","__esModule","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_types","require","t","getObjRef","node","nodes","file","scope","ref","isIdentifier","hasBinding","name","isMemberExpression","object","hasGlobal","Error","type","temp","generateUidIdentifierBasedOnNode","push","variableDeclaration","variableDeclarator","getPropRef","prop","property","toComputedKey","isLiteral","allowedSingleIdent","uid","computed","memberExpression","module"],"mappings":"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","file":"explode-assignable-expression.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar getObjRef = function getObjRef(node, nodes, file, scope) {\n  var ref;\n  if (t.isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      // this variable is declared in scope so we can be 100% sure\n      // that evaluating it multiple times wont trigger a getter\n      // or something else\n      return node;\n    } else {\n      // could possibly trigger a getter so we need to only evaluate\n      // it once\n      ref = node;\n    }\n  } else if (t.isMemberExpression(node)) {\n    ref = node.object;\n\n    if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {\n      // the object reference that we need to save is locally declared\n      // so as per the previous comment we can be 100% sure evaluating\n      // it multiple times will be safe\n      return ref;\n    }\n  } else {\n    throw new Error(\"We can't explode this node type \" + node.type);\n  }\n\n  var temp = scope.generateUidIdentifierBasedOnNode(ref);\n  nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(temp, ref)]));\n  return temp;\n};\n\n/**\n * [Please add a description.]\n */\n\nvar getPropRef = function getPropRef(node, nodes, file, scope) {\n  var prop = node.property;\n  var key = t.toComputedKey(node, prop);\n  if (t.isLiteral(key)) return key;\n\n  var temp = scope.generateUidIdentifierBasedOnNode(prop);\n  nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(temp, prop)]));\n  return temp;\n};\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node, nodes, file, scope, allowedSingleIdent) {\n  var obj;\n  if (t.isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, file, scope);\n  }\n\n  var ref, uid;\n\n  if (t.isIdentifier(node)) {\n    ref = node;\n    uid = obj;\n  } else {\n    var prop = getPropRef(node, nodes, file, scope);\n    var computed = node.computed || t.isLiteral(prop);\n    uid = ref = t.memberExpression(obj, prop, computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n};\n\nmodule.exports = exports[\"default\"];"]}