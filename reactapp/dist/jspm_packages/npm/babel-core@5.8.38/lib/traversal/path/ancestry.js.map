{"version":3,"sources":["../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/traversal/path/ancestry.js"],"names":["exports","__esModule","findParent","getFunctionParent","getStatementParent","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","getAncestry","inType","inShadow","_interopRequireDefault","obj","_interopRequireWildcard","newObj","key","Object","prototype","hasOwnProperty","call","_types","require","t","_index","_index2","callback","path","parentPath","isFunction","isProgram","Array","isArray","container","paths","deepest","i","ancestries","earliest","keys","VISITOR_KEYS","type","_arr","_i","length","ancestry","listKey","earliestKeyIndex","indexOf","parentKey","currentKeyIndex","filter","_this","minDepth","Infinity","lastCommonIndex","lastCommon","map","unshift","first","depthLoop","shouldMatch","_arr2","_i2","Error","push","_arr3","arguments","_i3","node","shadow","isArrowFunctionExpression"],"mappings":"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","file":"ancestry.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\nexports.findParent = findParent;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.inType = inType;\nexports.inShadow = inShadow;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n/**\n * Call the provided `callback` with the `NodePath`s of all the parents.\n * When the `callback` returns a truthy value, we return that node path.\n */\n\nfunction findParent(callback) {\n  var path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nfunction getFunctionParent() {\n  return this.findParent(function (path) {\n    return path.isFunction() || path.isProgram();\n  });\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nfunction getStatementParent() {\n  var path = this;\n  do {\n    if (Array.isArray(path.container)) {\n      return path;\n    }\n  } while (path = path.parentPath);\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    var earliest;\n    var keys = t.VISITOR_KEYS[deepest.type];\n\n    var _arr = ancestries;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var ancestry = _arr[_i];\n      var path = ancestry[i + 1];\n\n      // first path\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      // handle containers\n      if (path.listKey && earliest.listKey === path.listKey) {\n        // we're in the same container so check if we're earlier\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      // handle keys\n      var earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      var currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        // key appears before so it's earlier\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  var minDepth = Infinity;\n\n  // last common ancestor\n  var lastCommonIndex, lastCommon;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  var ancestries = paths.map(function (path) {\n    var ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== _this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  var first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (var i = 0; i < minDepth; i++) {\n    var shouldMatch = first[i];\n\n    var _arr2 = ancestries;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var ancestry = _arr2[_i2];\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nfunction getAncestry() {\n  var path = this;\n  var paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inType() {\n  var path = this;\n  while (path) {\n    var _arr3 = arguments;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var type = _arr3[_i3];\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n\n  return false;\n}\n\n/**\n * Check if we're inside a shadowed function.\n */\n\nfunction inShadow(key) {\n  var path = this;\n  do {\n    if (path.isFunction()) {\n      var shadow = path.node.shadow;\n      if (shadow) {\n        // this is because sometimes we may have a `shadow` value of:\n        //\n        //   { this: false }\n        //\n        // we need to catch this case if `inShadow` has been passed a `key`\n        if (!key || shadow[key] !== false) {\n          return path;\n        }\n      } else if (path.isArrowFunctionExpression()) {\n        return path;\n      }\n\n      // normal function, we've found our function context\n      return null;\n    }\n  } while (path = path.parentPath);\n  return null;\n}"]}