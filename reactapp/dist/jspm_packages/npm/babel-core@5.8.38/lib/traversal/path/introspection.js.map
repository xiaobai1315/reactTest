{"version":3,"sources":["../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/traversal/path/introspection.js"],"names":["exports","__esModule","matchesPattern","has","isnt","equals","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","isCompletionRecord","isStatementOrBlock","referencesImport","getSource","willIMaybeExecuteBefore","_guessExecutionStatusRelativeTo","resolve","_resolve","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_interopRequireDefault","_lodashCollectionIncludes","require","_lodashCollectionIncludes2","_types","t","pattern","allowPartial","isMemberExpression","parts","split","search","node","i","matches","name","part","length","shift","isIdentifier","isLiteral","value","computed","property","unshift","object","isThisExpression","val","Array","isArray","is","type","isType","parentPath","isFor","replacement","isArrowFunctionExpression","isExpression","isBlockStatement","allowInsideFunction","path","first","container","isFunction","isProgram","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","moduleSource","importName","isReferencedIdentifier","binding","scope","getBinding","kind","parent","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","end","hub","file","code","slice","start","target","targetFuncParent","getFunctionParent","selfFuncParent","targetPaths","getAncestry","selfPaths","commonPath","targetIndex","selfIndex","selfPath","indexOf","targetRelationship","selfRelationship","listKey","targetKeyPosition","VISITOR_KEYS","selfKeyPosition","dangerous","resolved","push","isVariableDeclarator","get","constant","isTypeCastExpression","targetKey","toComputedKey","targetName","isObjectExpression","props","_arr","_i","prop","isProperty","match","isArrayExpression","isNaN","elems","elem"],"mappings":"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","file":"introspection.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports.resolve = resolve;\nexports._resolve = _resolve;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nfunction matchesPattern(pattern, allowPartial) {\n  // not a member expression\n  if (!this.isMemberExpression()) return false;\n\n  var parts = pattern.split(\".\");\n  var search = [this.node];\n  var i = 0;\n\n  function matches(name) {\n    var part = parts[i];\n    return part === \"*\" || name === part;\n  }\n\n  while (search.length) {\n    var node = search.shift();\n\n    if (allowPartial && i === parts.length) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      // this part doesn't match\n      if (!matches(node.name)) return false;\n    } else if (t.isLiteral(node)) {\n      // this part doesn't match\n      if (!matches(node.value)) return false;\n    } else if (t.isMemberExpression(node)) {\n      if (node.computed && !t.isLiteral(node.property)) {\n        // we can't deal with this\n        return false;\n      } else {\n        search.unshift(node.property);\n        search.unshift(node.object);\n        continue;\n      }\n    } else if (t.isThisExpression(node)) {\n      if (!matches(\"this\")) return false;\n    } else {\n      // we can't deal with this\n      return false;\n    }\n\n    // too many parts\n    if (++i > parts.length) {\n      return false;\n    }\n  }\n\n  return i === parts.length;\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nfunction has(key) {\n  var val = this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Alias of `has`.\n */\n\nvar is = has;\n\nexports.is = is;\n/**\n * Opposite of `has`.\n */\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nfunction isCompletionRecord(allowInsideFunction) {\n  var path = this;\n  var first = true;\n\n  do {\n    var container = path.container;\n\n    // we're in a function so can't be a completion record\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return _lodashCollectionIncludes2[\"default\"](t.STATEMENT_OR_BLOCK_KEYS, this.key);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n\n  var binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  var path = binding.path;\n  var parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nfunction getSource() {\n  var node = this.node;\n  if (node.end) {\n    return this.hub.file.code.slice(node.start, node.end);\n  } else {\n    return \"\";\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execuete\n * before or after the input `target` element.\n */\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  // check if the two paths are in different functions, we can't track execution of these\n  var targetFuncParent = target.scope.getFunctionParent();\n  var selfFuncParent = this.scope.getFunctionParent();\n  if (targetFuncParent !== selfFuncParent) {\n    return \"function\";\n  }\n\n  var targetPaths = target.getAncestry();\n  //if (targetPaths.indexOf(this) >= 0) return \"after\";\n\n  var selfPaths = this.getAncestry();\n\n  // get ancestor where the branches intersect\n  var commonPath;\n  var targetIndex;\n  var selfIndex;\n  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {\n    var selfPath = selfPaths[selfIndex];\n    targetIndex = targetPaths.indexOf(selfPath);\n    if (targetIndex >= 0) {\n      commonPath = selfPath;\n      break;\n    }\n  }\n  if (!commonPath) {\n    return \"before\";\n  }\n\n  // get the relationship paths that associate these nodes to their common ancestor\n  var targetRelationship = targetPaths[targetIndex - 1];\n  var selfRelationship = selfPaths[selfIndex - 1];\n  if (!targetRelationship || !selfRelationship) {\n    return \"before\";\n  }\n\n  // container list so let's see which one is after the other\n  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {\n    return targetRelationship.key > selfRelationship.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);\n  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);\n  return targetKeyPosition > selfKeyPosition ? \"before\" : \"after\";\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resolve(dangerous, resolved) {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n      var binding = this.scope.getBinding(this.node.name);\n      if (!binding) return;\n\n      // reassigned so we can't really resolve it\n      if (!binding.constant) return;\n\n      // todo - lookup module in dependency graph\n      if (binding.kind === \"module\") return;\n\n      if (binding.path !== this) {\n        return binding.path.resolve(dangerous, resolved);\n      }\n    } else if (this.isTypeCastExpression()) {\n      return this.get(\"expression\").resolve(dangerous, resolved);\n    } else if (dangerous && this.isMemberExpression()) {\n      // this is dangerous, as non-direct target assignments will mutate it's state\n      // making this resolution inaccurate\n\n      var targetKey = this.toComputedKey();\n      if (!t.isLiteral(targetKey)) return;\n\n      var targetName = targetKey.value;\n\n      var target = this.get(\"object\").resolve(dangerous, resolved);\n\n      if (target.isObjectExpression()) {\n        var props = target.get(\"properties\");\n        var _arr = props;\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var prop = _arr[_i];\n          if (!prop.isProperty()) continue;\n\n          var key = prop.get(\"key\");\n\n          // { foo: obj }\n          var match = prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n          // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n          match = match || key.isLiteral({ value: targetName });\n\n          if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n        }\n      } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n        var elems = target.get(\"elements\");\n        var elem = elems[targetName];\n        if (elem) return elem.resolve(dangerous, resolved);\n      }\n    }\n}"]}