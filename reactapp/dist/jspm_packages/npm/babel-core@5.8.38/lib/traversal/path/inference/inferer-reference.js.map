{"version":3,"sources":["../../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/traversal/path/inference/inferer-reference.js"],"names":["exports","__esModule","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_types","require","t","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","voidTypeAnnotation","numberTypeAnnotation","path","types","unionTypeAnnotation","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","rawConstantViolations","reverse","visitedScopes","_arr","_i","violation","violationScope","concat","_arr2","_i2","getTypeAnnotation","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","value","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","test","paths","_path","shift","isLogicalExpression","isBinaryExpression","type","module"],"mappings":"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","file":"inferer-reference.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    var rawConstantViolations = constantViolations.reverse();\n    var visitedScopes = [];\n    constantViolations = [];\n    var _arr = rawConstantViolations;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var violation = _arr[_i];\n      var violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }\n\n    // add back on function constant violations since we can't track calls\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    // push on inferred types of violated paths\n    var _arr2 = constantViolations;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var violation = _arr2[_i2];\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  //\n  var typeofPath;\n  var typePath;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  // turn type value into a type annotation\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getParentConditionalPath(path) {\n  var parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}