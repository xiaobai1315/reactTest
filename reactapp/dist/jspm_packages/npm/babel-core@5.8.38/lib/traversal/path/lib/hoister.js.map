{"version":3,"sources":["../../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/traversal/path/lib/hoister.js"],"names":["exports","__esModule","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_classCallCheck","instance","Constructor","TypeError","_transformationHelpersReact","require","react","_types","t","referenceVisitor","ReferencedIdentifier","node","parent","scope","state","isJSXIdentifier","isCompatTag","name","binding","getBinding","constant","bindings","_arr","constantViolations","_i","length","violationPath","breakOnScopePaths","concat","getAncestry","PathHoister","path","scopes","isCompatibleScope","bindingIdentifierEquals","identifier","getCompatibleScopes","push","indexOf","getAttachmentPath","pop","isFunction","hasOwnParamBindings","get","getNextScopeStatementParent","isProgram","getStatementParent","hasOwnBinding","kind","run","_hoisted","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","insertBefore","variableDeclaration","variableDeclarator","parentPath","isJSXElement","container","children","JSXExpressionContainer","replaceWith","module"],"mappings":"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","file":"hoister.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformationHelpersReact = require(\"../../../transformation/helpers/react\");\n\nvar react = _interopRequireWildcard(_transformationHelpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar referenceVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (this.isJSXIdentifier() && react.isCompatTag(node.name)) {\n      return;\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    var binding = scope.getBinding(node.name);\n    if (!binding) return;\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(node.name)) return;\n\n    if (binding.constant) {\n      state.bindings[node.name] = binding;\n    } else {\n      var _arr = binding.constantViolations;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var violationPath = _arr[_i];\n        state.breakOnScopePaths = state.breakOnScopePaths.concat(violationPath.getAncestry());\n      }\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar PathHoister = (function () {\n  function PathHoister(path, scope) {\n    _classCallCheck(this, PathHoister);\n\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {\n    for (var key in this.bindings) {\n      var binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {\n    var scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {\n    var scopes = this.scopes;\n\n    var scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        return scope.path.get(\"body\").get(\"body\")[0];\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeStatementParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeStatementParent();\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getNextScopeStatementParent = function getNextScopeStatementParent() {\n    var scope = this.scopes.pop();\n    if (scope) return scope.path.getStatementParent();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {\n    for (var name in this.bindings) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      var binding = this.bindings[name];\n      if (binding.kind === \"param\") return true;\n    }\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.run = function run() {\n    var node = this.path.node;\n    if (node._hoisted) return;\n    node._hoisted = true;\n\n    this.path.traverse(referenceVisitor, this);\n\n    this.getCompatibleScopes();\n\n    var attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n\n    attachTo.insertBefore([t.variableDeclaration(\"var\", [t.variableDeclarator(uid, this.path.node)])]);\n\n    var parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(uid);\n  };\n\n  return PathHoister;\n})();\n\nexports[\"default\"] = PathHoister;\nmodule.exports = exports[\"default\"];"]}