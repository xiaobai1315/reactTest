{"version":3,"sources":["../../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/traversal/path/evaluation.js"],"names":["exports","__esModule","evaluateTruthy","evaluate","VALID_CALLEES","res","confident","value","undefined","path","node","isSequenceExpression","exprs","get","length","isLiteral","regex","isConditionalExpression","isTypeCastExpression","isIdentifier","scope","hasBinding","name","Infinity","NaN","isMemberExpression","parentPath","isCallExpression","callee","_property","object","_value","type","isReferencedIdentifier","binding","getBinding","hasValue","resolved","resolve","isUnaryExpression","prefix","argument","arg","operator","isFunction","isArrayExpression","isObjectExpression","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","uncertain","isBinaryExpression","Math","pow","context","func","indexOf","global","property","args","map","apply"],"mappings":"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","file":"evaluation.js","sourcesContent":["/* */ \n\"format cjs\";\n/* eslint eqeqeq: 0 */\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nvar VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nfunction evaluateTruthy() {\n  var res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value }`. `confident` indicates\n * whether or not we had to drop out of evaluating the expression because of\n * hitting an unknown node that we couldn't confidently find the value of.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined }\n *\n */\n\nfunction evaluate() {\n  var confident = true;\n\n  var value = evaluate(this);\n  if (!confident) value = undefined;\n  return {\n    confident: confident,\n    value: value\n  };\n\n  function evaluate(path) {\n    if (!confident) return;\n\n    var node = path.node;\n\n    if (path.isSequenceExpression()) {\n      var exprs = path.get(\"expressions\");\n      return evaluate(exprs[exprs.length - 1]);\n    }\n\n    if (path.isLiteral()) {\n      if (node.regex) {\n        // we have a regex and we can't represent it natively\n      } else {\n          return node.value;\n        }\n    }\n\n    if (path.isConditionalExpression()) {\n      if (evaluate(path.get(\"test\"))) {\n        return evaluate(path.get(\"consequent\"));\n      } else {\n        return evaluate(path.get(\"alternate\"));\n      }\n    }\n\n    if (path.isTypeCastExpression()) {\n      return evaluate(path.get(\"expression\"));\n    }\n\n    if (path.isIdentifier() && !path.scope.hasBinding(node.name, true)) {\n      if (node.name === \"undefined\") {\n        return undefined;\n      } else if (node.name === \"Infinity\") {\n        return Infinity;\n      } else if (node.name === \"NaN\") {\n        return NaN;\n      }\n    }\n\n    // \"foo\".length\n    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {\n      var _property = path.get(\"property\");\n      var object = path.get(\"object\");\n\n      if (object.isLiteral() && _property.isIdentifier()) {\n        var _value = object.node.value;\n        var type = typeof _value;\n        if (type === \"number\" || type === \"string\") {\n          return _value[_property.node.name];\n        }\n      }\n    }\n\n    if (path.isReferencedIdentifier()) {\n      var binding = path.scope.getBinding(node.name);\n      if (binding && binding.hasValue) {\n        return binding.value;\n      } else {\n        var resolved = path.resolve();\n        if (resolved === path) {\n          return confident = false;\n        } else {\n          return evaluate(resolved);\n        }\n      }\n    }\n\n    if (path.isUnaryExpression({ prefix: true })) {\n      var argument = path.get(\"argument\");\n      var arg = evaluate(argument);\n      switch (node.operator) {\n        case \"void\":\n          return undefined;\n        case \"!\":\n          return !arg;\n        case \"+\":\n          return +arg;\n        case \"-\":\n          return -arg;\n        case \"~\":\n          return ~arg;\n        case \"typeof\":\n          if (argument.isFunction()) {\n            return \"function\";\n          } else {\n            return typeof arg;\n          }\n      }\n    }\n\n    if (path.isArrayExpression() || path.isObjectExpression()) {\n      // we could evaluate these but it's probably impractical and not very useful\n    }\n\n    if (path.isLogicalExpression()) {\n      // If we are confident that one side of an && is false, or one side of\n      // an || is true, we can be confident about the entire expression\n      var wasConfident = confident;\n      var left = evaluate(path.get(\"left\"));\n      var leftConfident = confident;\n      confident = wasConfident;\n      var right = evaluate(path.get(\"right\"));\n      var rightConfident = confident;\n      var uncertain = leftConfident !== rightConfident;\n      confident = leftConfident && rightConfident;\n\n      switch (node.operator) {\n        case \"||\":\n          if ((left || right) && uncertain) {\n            confident = true;\n          }\n          return left || right;\n        case \"&&\":\n          if (!left && leftConfident || !right && rightConfident) {\n            confident = true;\n          }\n          return left && right;\n      }\n    }\n\n    if (path.isBinaryExpression()) {\n      var left = evaluate(path.get(\"left\"));\n      var right = evaluate(path.get(\"right\"));\n\n      switch (node.operator) {\n        case \"-\":\n          return left - right;\n        case \"+\":\n          return left + right;\n        case \"/\":\n          return left / right;\n        case \"*\":\n          return left * right;\n        case \"%\":\n          return left % right;\n        case \"**\":\n          return Math.pow(left, right);\n        case \"<\":\n          return left < right;\n        case \">\":\n          return left > right;\n        case \"<=\":\n          return left <= right;\n        case \">=\":\n          return left >= right;\n        case \"==\":\n          return left == right;\n        case \"!=\":\n          return left != right;\n        case \"===\":\n          return left === right;\n        case \"!==\":\n          return left !== right;\n        case \"|\":\n          return left | right;\n        case \"&\":\n          return left & right;\n        case \"^\":\n          return left ^ right;\n        case \"<<\":\n          return left << right;\n        case \">>\":\n          return left >> right;\n        case \">>>\":\n          return left >>> right;\n      }\n    }\n\n    if (path.isCallExpression()) {\n      var callee = path.get(\"callee\");\n      var context;\n      var func;\n\n      // Number(1);\n      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n        func = global[node.callee.name];\n      }\n\n      if (callee.isMemberExpression()) {\n        var object = callee.get(\"object\");\n        var property = callee.get(\"property\");\n\n        // Math.min(1, 2)\n        if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0) {\n          context = global[object.node.name];\n          func = context[property.node.name];\n        }\n\n        // \"abc\".charCodeAt(4)\n        if (object.isLiteral() && property.isIdentifier()) {\n          var type = typeof object.node.value;\n          if (type === \"string\" || type === \"number\") {\n            context = object.node.value;\n            func = context[property.node.name];\n          }\n        }\n      }\n\n      if (func) {\n        var args = path.get(\"arguments\").map(evaluate);\n        if (!confident) return;\n\n        return func.apply(context, args);\n      }\n    }\n\n    confident = false;\n  }\n}"]}