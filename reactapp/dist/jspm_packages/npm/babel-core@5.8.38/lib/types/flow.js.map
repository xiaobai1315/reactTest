{"version":3,"sources":["../../../../../../jspm_packages/npm/babel-core@5.8.38/lib/types/flow.js"],"names":["exports","__esModule","createUnionTypeAnnotation","removeTypeDuplicates","createTypeAnnotationBasedOnTypeof","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","_index","require","t","types","flattened","length","unionTypeAnnotation","nodes","generics","bases","typeGroups","i","node","indexOf","isAnyTypeAnnotation","isFlowBaseAnnotation","type","isUnionTypeAnnotation","concat","push","isGenericTypeAnnotation","_name","id","name","existing","typeParameters","params","_name2","stringTypeAnnotation","numberTypeAnnotation","voidTypeAnnotation","booleanTypeAnnotation","genericTypeAnnotation","identifier","Error"],"mappings":"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","file":"flow.js","sourcesContent":["/* */ \n\"format cjs\";\n\"use strict\";\n\nexports.__esModule = true;\nexports.createUnionTypeAnnotation = createUnionTypeAnnotation;\nexports.removeTypeDuplicates = removeTypeDuplicates;\nexports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containg them.\n */\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return t.unionTypeAnnotation(flattened);\n  }\n}\n\n/**\n * Dedupe type annotations.\n */\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n\n  // store union type groups to circular references\n  var typeGroups = [];\n\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (t.isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    //\n    if (t.isFlowBaseAnnotation(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    //\n    if (t.isUnionTypeAnnotation(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (t.isGenericTypeAnnotation(node)) {\n      var _name = node.id.name;\n\n      if (generics[_name]) {\n        var existing = generics[_name];\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[_name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  // add back in generics\n  for (var _name2 in generics) {\n    types.push(generics[_name2]);\n  }\n\n  return types;\n}\n\n/**\n * Create a type anotation based on typeof expression.\n */\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return t.stringTypeAnnotation();\n  } else if (type === \"number\") {\n    return t.numberTypeAnnotation();\n  } else if (type === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (type === \"boolean\") {\n    return t.booleanTypeAnnotation();\n  } else if (type === \"function\") {\n    return t.genericTypeAnnotation(t.identifier(\"Function\"));\n  } else if (type === \"object\") {\n    return t.genericTypeAnnotation(t.identifier(\"Object\"));\n  } else if (type === \"symbol\") {\n    return t.genericTypeAnnotation(t.identifier(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}"]}